import ListUtils PairUtils NatUtils

library CommitScore


let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let no_msg = Nil {Message}
let zero = Uint128 0
let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
    
let fst =
  tfun 'A =>
  tfun 'B =>
  fun (p : Pair ('A) ('B)) =>
    match p with
    | Pair a b => a
    end

let init_user_score = 
        let zeros = Uint128 0 in
        let fs_variables = Pair{(Uint128) (Uint128)} zeros zeros in
        let sc_variables = Pair{(Uint128) (Uint128)} zeros zeros in
        let scores = Pair {(Pair(Uint128) (Uint128)) (Pair(Uint128) (Uint128))} fs_variables sc_variables in
        scores

let getMessage = @fst String (Pair ByStr20 Int32)
let pair_1_snd = @snd String (Pair ByStr20 Int32)
let getUser = @fst ByStr20 Int32
let getUserNo = @snd ByStr20 Int32

let getFirst = @fst (Pair Uint128 Uint128) (Pair Uint128 Uint128)
let getEvaluateScore = @fst Uint128 Uint128
let getCommitScore = @snd Uint128 Uint128

let getSecond = @snd (Pair Uint128 Uint128) (Pair Uint128 Uint128)
let getPlanScore = @fst Uint128 Uint128
let getTotalScore = @snd Uint128 Uint128


let not_owner_code = Int32 1 
let newly_created_code = Int32 2
let succeed_add_code = Int32 3
    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract CommitScore
(initialOwner : ByStr20)
 

(* Initial balance is t stated explicitly: it's initialized when creating the contract. *)

(*  struct commitscore plannerScore evaluaterscore totalLevel*)
field contributorScore :
    Map ByStr20 (Map (ByStr20) (Pair (Pair(Uint128) (Uint128)) (Pair(Uint128) (Uint128))))
   = Emp ByStr20 (Map (ByStr20) (Pair (Pair(Uint128) (Uint128))  (Pair(Uint128) (Uint128))))


(* token is mintable and inflatable. inital token supply is 20 million *)
(* owner ship is transferable initialOwner*)
field owner :  ByStr20  =  initialOwner
field ze : Uint128 = Uint128 0

transition addReputationScore (userAddress : ByStr20, communityAddress : ByStr20, addedScore : Uint128, changedField : String)
  contract_owner <- owner;
  is_owner = builtin eq contract_owner _sender;
  match is_owner with 
  | True => 
      cs <- contributorScore;
      zero <- ze;
      user_score <- contributorScore[userAddress][communityAddress];
      match user_score with
      | Some v =>
              evaluate = "EVALUATE";
              is_evaluate_score = builtin eq changedField evaluate;
              match is_evaluate_score with
              | True =>
                  (*add evaluate score *)
              | False =>
                commit = "COMMIT";
                is_evaluate_score = builtin eq changedField commit;
                match is_evaluate_score with
                | True =>
                  (*add commit score *)
                | False =>
                    plan = "PLAN";
                    is_plan_score = builtin eq changedField plan;
                    match  is_evaluate_score with
                    | True =>
                        (*add plan score *)
                    | False =>
                        (*pass *)
                    end

                end
              end
      | None =>
          score = init_user_score;
          contributorScore[userAddress][communityAddress] := score
      end
  | False => 
          score = init_user_score
  end
end
